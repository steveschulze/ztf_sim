"""Routines for working with the ZTF discrete field grid"""

import numpy as np
import pandas as pd
import astropy.coordinates as coord
import astropy.units as u
from astropy.time import Time
from collections import defaultdict
import itertools
from .utils import *
from .SkyBrightness import SkyBrightness
from .constants import BASE_DIR, P48_loc, P48_slew_pars, PROGRAM_IDS, FILTER_IDS
from .constants import TIME_BLOCK_SIZE, MAX_AIRMASS, EXPOSURE_TIME, READOUT_TIME
from .constants import slew_time


class Fields(object):
    """
    Class for accessing field grid.

    Attributes:
        loc (EarthLocation): Location of the observatory.
        current_block_night_mjd (int): Current block night in Modified Julian Date.
        current_blocks (list): List of current blocks.
        block_alt (DataFrame): DataFrame of block altitudes.
        block_az (DataFrame): DataFrame of block azimuths.
        _current_observable_hours_night_mjd (int): Current observable hours night in Modified Julian Date.
        observable_hours (Series): Series of observable hours.
        Sky (SkyBrightness): Instance of SkyBrightness class.

    Methods:
        _load_fields(field_filename):
            Loads a field grid of the format generated by Tom B.
            Expects field_id, ra (deg), dec (deg) columns.

        _field_coords(cuts=None):
            Generate an astropy SkyCoord object for current fields.

        compute_blocks(time, time_block_size=TIME_BLOCK_SIZE):
            Store alt/az for tonight in blocks.

        compute_observability(time, time_block_size=TIME_BLOCK_SIZE):
            For each field_id, use the number of nighttime blocks with non-negative limiting mags to compute observability time.

        alt_az(time, cuts=None):
            Return Altitude & Azimuth by field at a given time.

        overhead_time(current_state, cuts=None):
            Calculate overhead time in seconds from current position.

        select_fields(ra_range=None, dec_range=None, l_range=None, b_range=None, abs_b_range=None, ecliptic_lon_range=None, ecliptic_lat_range=None, grid_id=None, observable_hours_range=None):
            Select a subset of fields based on their sky positions.
            grid_id is a scalar.
            Returns a boolean array indexed by field_id.

        select_field_ids(**kwargs):
            Returns a pandas index."""

    def __init__(self, field_filename=BASE_DIR + '../data/ZTF_Fields.txt'):
        """
        Initializes the Fields class.

        Parameters:
        field_filename (str): The path to the file containing field data. Defaults to '../data/ZTF_Fields.txt'.

        Attributes:
        loc (object): The location of the P48 telescope.
        current_block_night_mjd (float): The current block night in Modified Julian Date (MJD).
        current_blocks (object): The current blocks of observations.
        block_alt (float): The altitude of the current block.
        block_az (float): The azimuth of the current block.
        _current_observable_hours_night_mjd (float): The current observable hours night in Modified Julian Date (MJD).
        observable_hours (object): The observable hours for the night.
        Sky (SkyBrightness): An instance of the SkyBrightness class.
        """

        self._load_fields(field_filename)
        self.loc = P48_loc
        self.current_block_night_mjd = None  # np.floor(time.mjd)
        self.current_blocks = None
        self.block_alt = None
        self.block_az = None
        self._current_observable_hours_night_mjd = None  # np.floor(time.mjd)
        self.observable_hours = None
        self.Sky = SkyBrightness()

    def _load_fields(self, field_filename):
        """
        Loads a field grid of the format generated by Tom B.

        The file is expected to have columns: field_id, ra (deg), dec (deg), 
        ebv, l, b, ecliptic_lon, ecliptic_lat, and number. Only the columns 
        field_id, ra, dec, l, b, ecliptic_lon, and ecliptic_lat are used.

        Args:
            field_filename (str): The path to the file containing the field grid data.

        Returns:
            None

        Notes:
            - The method filters out fields with a declination below -32 degrees.
            - It assigns a grid_id to each field based on predefined boundaries.
            - The resulting DataFrame is stored in the instance variable `self.fields`.
            - The method also initializes `self.field_coords` with the field coordinates.
        """

        df = pd.read_csv(field_filename,
            names=['field_id','ra','dec','ebv','l','b',
                'ecliptic_lon', 'ecliptic_lat', 'number'],
            sep='\s+',usecols=['field_id','ra','dec', 'l','b', 
                'ecliptic_lon', 'ecliptic_lat'],index_col='field_id',
            skiprows=1)


        # drop fields below dec of -32 degrees for speed
        # (grid_id = 0 has a row at -31.5)
        df = df[df['dec'] >= -32]

        # label the grid ids
        grid_id_boundaries = \
            {0: {'min':1,'max':999},
             1: {'min':1001,'max':1999},
             2: {'min':2001,'max':2999},
             3: {'min':3001,'max':3999}}

        # intialize with a bad int value
        df['grid_id'] = 99

        for grid_id, bounds in list(grid_id_boundaries.items()):
            w = (df.index >= bounds['min']) &  \
                    (df.index <= bounds['max'])
            df.loc[w,'grid_id'] = grid_id

        self.fields = df
        self.field_coords = self._field_coords()

    def _field_coords(self, cuts=None):
        """
        Generate an astropy SkyCoord object for current fields.

        Parameters:
        cuts (array-like, optional): Indices or boolean array to select specific fields. 
                                     If None, all fields are used. Default is None.

        Returns:
        astropy.coordinates.SkyCoord: SkyCoord object containing the coordinates of the selected fields.
        """

        if cuts is None:
            fields = self.fields
        else:
            fields = self.fields[cuts]
        return coord.SkyCoord(fields['ra'],
                              fields['dec'], frame='icrs', unit='deg')

    def compute_blocks(self, time, time_block_size=TIME_BLOCK_SIZE):
        """
        Compute and store altitude and azimuth blocks for the given night.

        This method calculates the altitude and azimuth for the specified time
        in blocks of size `time_block_size`. It stores the results in DataFrames
        indexed by field_id, with columns representing block numbers. It also
        computes the mean observable airmass for the time periods when the
        airmass is within the acceptable range.

        Parameters:
        -----------
        time : astropy.time.Time
            The time for which to compute the blocks.
        time_block_size : float, optional
            The size of each time block in seconds. Default is TIME_BLOCK_SIZE.

        Returns:
        --------
        None
        """

        # check if we've already computed for tonight:
        block_night = np.floor(time.mjd).astype(int)
        if self.current_block_night_mjd == block_night:
            return

        self.current_block_night_mjd = block_night

        blocks, times = nightly_blocks(time, time_block_size=time_block_size)
        self.current_blocks = blocks
        self.current_block_times = times

        alt_blocks = {}
        az_blocks = {}
        for bi, ti in zip(blocks, times):
            altaz = self.alt_az(ti)
            alt_blocks[bi] = altaz.alt
            az_blocks[bi] = altaz.az

        # DataFrames indexed by field_id, columns are block numbers
        self.block_alt = pd.DataFrame(alt_blocks)
        self.block_az = pd.DataFrame(az_blocks)

        block_airmass = altitude_to_airmass(self.block_alt)
        w = (block_airmass <= MAX_AIRMASS) & (block_airmass >= 1.0)
        # average airmass over the time we're above MAX_AIRMASS
        mean_observable_airmass = block_airmass[w].mean(axis=1)
        mean_observable_airmass.name = 'mean_observable_airmass'
        self.mean_observable_airmass = mean_observable_airmass

    def compute_observability(self, time, time_block_size=TIME_BLOCK_SIZE):
        """
        For each field_id, use the number of nighttime blocks with non-negative limiting mags to compute observability time.

        This method calculates the observability time by using pre-computed blocks and limiting magnitudes. It dosn't count telescope limits or moon exclusion times

        Parameters:
        -----------
        time : astropy.time.Time
            The time at which to compute the observability.
        time_block_size : astropy.units.Quantity, optional
            The size of the time blocks to use for computation, by default TIME_BLOCK_SIZE.

        Returns:
        --------
        None
            The result is stored in the instance variable `self.observable_hours`.

        Notes:
        ------
        - This method updates `self.observable_hours` with the computed observable hours for each field_id.
        - It also updates `self._current_observable_hours_night_mjd` to the current block night.
        """

        self.compute_blocks(time, time_block_size=time_block_size)

        block_night = np.floor(time.mjd).astype(int)
        if self._current_observable_hours_night_mjd == block_night:
            return

        lim_mags = {}
        # use pre-computed blocks
        for bi, ti in zip(self.current_blocks, self.current_block_times):
            df = self.fields.copy()
            df_alt = self.block_alt[bi]
            df_alt.name = 'altitude'
            df = df.join(df_alt, on='field_id')
            df_az = self.block_az[bi]
            df_az.name = 'azimuth'
            df = df.join(df_az, on='field_id')
            # for observability considerations it's sufficient to use one band
            fid=2
            df_limmag, df_sky = \
                compute_limiting_mag(df, ti, self.Sky, filter_id = fid)
            lim_mags[bi] = df_limmag

        df_lim = pd.DataFrame(lim_mags)

        observable_hours = (df_lim > 0).sum(axis=1) * \
            (TIME_BLOCK_SIZE.to(u.hour))
        observable_hours.name = 'observable_hours'
        self.observable_hours = observable_hours
        self._current_observable_hours_night_mjd = block_night

    def alt_az(self, time, cuts=None):
        """
        Return the Altitude and Azimuth by field at a given time.

        Parameters:
        time : `astropy.time.Time`
            The time at which to calculate the Altitude and Azimuth.
        cuts : array-like, optional
            A boolean array or index array to specify a subset of fields. If None, 
            all fields are used. Specifying cuts can make the computation slower.

        Returns:
        pd.DataFrame
            A DataFrame with columns 'alt' (Altitude) and 'az' (Azimuth) for the 
            specified fields, indexed by the field index.
        """

        if cuts is None:
            index = self.fields.index
            fieldsAltAz = self.field_coords.transform_to(
                coord.AltAz(obstime=time, location=self.loc))
        else:
            # warning: specifying cuts makes this much slower
            index = self.fields[cuts].index
            fieldsAltAz = self._field_coords(cuts=cuts).transform_to(
                coord.AltAz(obstime=time, location=self.loc))

        return pd.DataFrame({'alt': fieldsAltAz.alt, 'az': fieldsAltAz.az},
                            index=index)

    def overhead_time(self, current_state, cuts=None):
        """
        Calculate overhead time in seconds from the current position. Also returns current altitude, for convenience.

        Parameters:
        current_state (dict): A dictionary containing the current state of the system, including:
            - 'current_time': The current time.
            - 'current_domeaz': The current dome azimuth.
            - 'current_ha': The current hour angle.
            - 'current_dec': The current declination.
        cuts (pd.Series, optional): A boolean series indexed by field_id, as generated by select_fields. 
                        If None, all fields are considered.

        Returns:
        tuple: A tuple containing:
            - pd.DataFrame: A DataFrame with the overhead time in seconds for each field.
            - pd.DataFrame: A DataFrame with the current altitude and azimuth for each field.
        """

        if cuts is None:
            fields = self.fields
        else:
            fields = self.fields[cuts]

        df_altaz = self.alt_az(current_state['current_time'], cuts=cuts)
        df = fields.join(df_altaz)

        slews_by_axis = {'readout': READOUT_TIME}
        for axis in ['dome', 'dec', 'ha']:
            if axis == 'dome':
                current_coord = current_state['current_domeaz'].value
            if axis == 'ha':
                # convert to RA for ease of subtraction
                current_coord = HA_to_RA(current_state['current_ha'],
                                         current_state['current_time']).degree
            if axis == 'dec':
                current_coord = current_state['current_dec'].value
            coord = P48_slew_pars[axis]['coord']
            dangle = np.abs(df[coord] - current_coord)
            angle = np.where(dangle < (360. - dangle), dangle, 360. - dangle)
            slews_by_axis[axis] = slew_time(axis, angle * u.deg)

        dfslews = pd.DataFrame(slews_by_axis, index=df.index)

        dfmax = dfslews.max(axis=1)
        dfmax = pd.DataFrame(dfmax)
        dfmax.columns = ['overhead_time']

        return dfmax, df_altaz

    def select_fields(self,
                      ra_range=None, dec_range=None,
                      l_range=None, b_range=None,
                      abs_b_range=None,
                      ecliptic_lon_range=None, ecliptic_lat_range=None,
                      grid_id=None,
                      observable_hours_range=None):
        """
        Select a subset of fields based on their sky positions.

        Parameters:
        ra_range (list[float, float], optional): Range of right ascension [min, max].
        dec_range (list[float, float], optional): Range of declination [min, max].
        l_range (list[float, float], optional): Range of Galactic longitude [min, max].
        b_range (list[float, float], optional): Range of Galactic latitude [min, max].
        abs_b_range (list[float, float], optional): Range of absolute Galactic latitude [min, max].
        ecliptic_lon_range (list[float, float], optional): Range of ecliptic longitude [min, max].
        ecliptic_lat_range (list[float, float], optional): Range of ecliptic latitude [min, max].
        grid_id (scalar, optional): Specific grid ID to filter fields.
        observable_hours_range (list[float, float], optional): Range of observable hours [min, max].

        Returns:
        numpy.ndarray: Boolean array indexed by field_id indicating selected fields.
        """

        # start with a boolean True series:
        cuts = (self.fields['ra'] == self.fields['ra'])

        if observable_hours_range is not None:
            # check that we've computed observable_hours
            assert(self.observable_hours is not None)
            fields = self.fields.join(self.observable_hours)
        else:
            fields = self.fields

        range_keys = ['ra', 'dec', 'l', 'b', 'ecliptic_lon', 'ecliptic_lat',
                      'observable_hours']

        assert((b_range is None) or (abs_b_range is None))

        for i, arg in enumerate([ra_range, dec_range, l_range, b_range,
                                 ecliptic_lon_range, ecliptic_lat_range,
                                 observable_hours_range]):
            if arg is not None:
                cuts = cuts & (fields[range_keys[i]] >= arg[0]) & \
                    (fields[range_keys[i]] <= arg[1])

        # easier cuts for Galactic/Extragalactic
        if abs_b_range is not None:
            cuts = cuts & (np.abs(fields['b']) >= abs_b_range[0]) & \
                (np.abs(fields['b']) <= abs_b_range[1])

        scalar_keys = ['grid_id']

        for i, arg in enumerate([grid_id]):
            if arg is not None:
                cuts = cuts & (fields[scalar_keys[i]] == arg)

        return cuts

    def select_field_ids(self, **kwargs):
        """
        Select field IDs based on given criteria.

        This method applies the selection criteria provided via keyword arguments
        to filter fields and returns the index of the selected fields.

        Parameters:
        **kwargs: Arbitrary keyword arguments that define the selection criteria.

        Returns:
        pandas.Index: An index object containing the IDs of the selected fields.
        """

        cuts = self.select_fields(**kwargs)
        return self.fields[cuts].index
